#pragma config(Sensor, S3,		 lightSensor,					sensorLightActive)
#pragma config(Sensor, S1,		 touchSensor,		 sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//
#pragma platform(NXT)
#define speed 30
#define prata 63
#define branco 45
/*--------------------------------------------------------------------------------------------------------*\
|*																																																				*|
|*																					 - Line Tracker -																							*|
|*																						ROBOTC on NXT																								*|
|*																																																				*|
|*	This program allows your taskbot to follow a line in reverse.																					*|
|*																																																				*|
|*																				ROBOT CONFIGURATION																							*|
|*		NOTES:																																															*|
|*		1)	The Light Sensor is attached to the front of the robot.																					 *|
|*		2)	Be sure to take readings of your Light Sensor over the light and dark areas.	Once you have			*|
|*				the values, add them and divide by 2 to find your threshold.	Then, use your threshold as a			*|
|*				comparison in your program.																																			*|
|*																																																				*|
|*		MOTORS & SENSORS:																																										*|
|*		[I/O Port]							[Name]							[Type]							[Description]												*|
|*		Port B									motorB							NXT									Right motor													*|
|*		Port C									motorC							NXT									Left motor													*|
|*		Port 1									touchSensor					Touch Sensor				Front mounted												*|
|*		Port 3									lightSensor					Light Sensor				Front mounted												*|
\*--------------------------------------------------------------------------------------------------------*/

bool activate = false, fromLeft =false, eixoX = true, curve =false, direction=true;
int i=0;
int x = 0, y = 0, xneg=0, yneg=0;

void forcarCurva(int s);
void correcao();
void resetar();
void silverRote();
//funcao pra conectar com a supervisao, que deve ja estar executando
void checkBTLinkConnected(){
  while(true){
		if (nBTCurrentStreamIndex >= 0)
			break; // An existing Bluetooth connection is present.
  }
	setBluetoothRawDataMode();
	while (!bBTRawMode){
		// Wait for Bluecore to enter raw data mode
		wait1Msec(50);
	}
}

//funcao que envia os dados para a supervisao
task Sender(){
	ubyte msg[5];
	bool restoreCurve =false;
  int dist =0;
	while (true){
	  dist=((nMotorEncoder(motorB)+nMotorEncoder(motorC))/2)/21.3;//20.809248554;

		msg[0] = SensorValue(lightSensor);
		msg[1] = SensorValue(touchSensor);
    nxtDisplayCenteredBigTextLine(3, "%d",SensorValue(lightSensor));
		if(!curve && !restoreCurve){
			if(eixoX && direction){//+x
			  x = dist -xneg -y -yneg;//resultado em cm
		  }else if(eixoX && !direction){//-x
			  xneg = dist -x -y -yneg;//resultado em cm
		  }else if(!eixoX && direction){//+y
		    y = dist -yneg -x -xneg;//resultado em cm
		  }else {//-y
		    yneg = dist -y -x -xneg;//resultado em cm
		  }
			msg[2] = x-xneg;
			msg[3] = y-yneg;
			msg[4] = dist;
			//envia
			nxtWriteRawBluetooth(msg, 5);
	  }else{
	    restoreCurve = true;
	  }
	  if ((restoreCurve && !curve)){
	    nMotorEncoder(motorB) = 0;
	    nMotorEncoder(motorC) = 0;
	    x = 0;
	    xneg = 0;
	    y = 0;
	    yneg = 0;
	    restoreCurve  = false;
	  }
	  //reset
	  if(dist>100){
	    nMotorEncoder(motorB) = 0;
	    nMotorEncoder(motorC) = 0;
	    x = 0;
	    xneg = 0;
	    y = 0;
	    yneg = 0;
	  }
		wait1Msec(80);//delay necessario pra nao embaralhar os pacotes
	}
	return;
}

//funcao que recebe os comandos da supervisao
task Receiver(){
  int nNumbBytesRead;
	ubyte BytesRead[1];
  while (true){
    //faz uma leitura no buffer
	  nNumbBytesRead = nxtReadRawBluetooth(&BytesRead[0],  1);

		if (nNumbBytesRead == 0){//se nao tem nada, da um tempinho
			wait1Msec(10);
		}else if (nNumbBytesRead == 1 && BytesRead[0] == 'i'){//sinal de iniciar
		  nxtDisplayCenteredBigTextLine(3, "Working");
		  activate =true;
		}else if (nNumbBytesRead == 1 && BytesRead[0] == 'p'){//sinal de parar
		  nxtDisplayCenteredBigTextLine(3, "Idle");
		  motor[motorB] = 0;
		  motor[motorC] = 0;
		  activate =false;
		}else if (nNumbBytesRead == 1 && BytesRead[0] == 'r'){//sinal de reset
		  resetar();
		}
  }
}

task main(){

  //int rote[17]= {1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,1};
  //                      { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10};
  int rote[11]=           { 1,-1,-1, 1,-1,-1,-1,-1, 1, 1, 1};//1 =right, -1 left  /curva (sem o prata)
  int rotaEixos[11] =     { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};//0 = x, 1 = y       /eixo (sem o prata)
  int rotaDirection[11] = { 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1};//0 = +, 1 = -       /increment (sem o prata)

  checkBTLinkConnected();//inicia a conexao
  wait1Msec(50);// The program waits 50 milliseconds to initialize the light sensor.
  StartTask(Sender);//ativa o envio de dados
  StartTask(Receiver);//ativa a recepcao de dados

  while(true){if(activate){  //so executa se receber o sinal mudando activate pra true
    //sensor lendo preto
    if(SensorValue(lightSensor) < branco){//mantem direcao reta
      motor[motorB] = speed;
      motor[motorC] = speed;
    //sensor lendo prata
    // }else if(SensorValue(lightSensor) >= prata){//mantem direcao reta
      // motor[motorB] = speed;
      // motor[motorC] = speed;
    //sensor lendo branco
    }else if(SensorValue(lightSensor) >= prata){//prata
      silverRote();
    }else if (SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata){//branco
      correcao();
      wait1Msec(150);
      //se apos um tempo, continuar no branco
      if(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){//continua no branco
        correcao();
		    wait1Msec(400);
		    //se apos outro intervalo de tempo continuar no branco, chegamos em uma curva
		    if(SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata){
		      curve=true;
		      //curva, rotaciona ate achar preto ou prata
		      while(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){
		        //o sentido da rotacao eh dado pelo vetor rote
		        motor[motorB] = (-1)*rote[i]*speed;//curva
		        motor[motorC] = rote[i]*speed;
		      }
		      i++;
		      if(i==sizeof(rote)){//fim do ciclo
		        resetar();
		      }else{
		        //se a proxima curva for a 1, 3.. estamos andando no eixo Y
			      if(rotaEixos[i])  //teste
			        eixoX=false;
			      else
			        //se nao estamos andando no eixo X
			        eixoX=true;

			      if(rotaDirection[i])//sabemos o eixo pela proxima curva (definidos com base no mapa)
			        direction=false;
			      else
			        direction=true;

			      curve=false;
			      if(i==9){// curva da base
			        int motorstate = nMotorEncoder(motorB);
			        while ((nMotorEncoder(motorB)-motorstate)/21.3<41){

			        }
			        curve =true;
			        forcarCurva(-1);
			        while(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){
				        //o sentido da rotacao eh dado pelo vetor rote
				        motor[motorB] = (-1)*rote[i]*speed;//curva
				        motor[motorC] = rote[i]*speed;
				      }
			        i++;
			        //se a proxima curva for a 1, 3.. estamos andando no eixo Y
				      if(rotaEixos[i])  //teste
				        eixoX=false;
				      else
				        //se nao estamos andando no eixo X
				        eixoX=true;

				      if(rotaDirection[i])//sabemos o eixo pela proxima curva (definidos com base no mapa)
				        direction=false;
				      else
				        direction=true;

				      curve=false;
			      }
			    }
		    }
      }
    }
  }}
}
//calculo da odometria
//cm = ciclos
//17.3 = 360  | x = 360/17.3
//1 = x       | x =  20.809248554

//21.3 (compensar a perda com corrcoes de direcao)
void correcao(){
  if(fromLeft){//se veio da esquerda tenta a 1 correcao pra direita
    motor[motorB] = 0;//direita
    motor[motorC] = speed;
    fromLeft =false;
  }else{//se veio da direita tenta a 1 correcao pra esquerda
    motor[motorB] = speed;//esquerda
    motor[motorC] = 0;
    fromLeft =true;
  }
}
void forcarCurva(int s){
  motor[motorB] = speed;
  motor[motorC] = speed;
  wait1Msec(400);
	motor[motorB] = s*speed;
  motor[motorC] = (-1)*s*speed;
  wait1Msec(510);
}
void resetar(){
  nxtDisplayCenteredBigTextLine(3, "Idle");
  motor[motorB] = 0;
  motor[motorC] = 0;
  activate = false;
  eixoX = true;
  curve =false;
  direction=true;
  nMotorEncoder(motorB) = 0;
	nMotorEncoder(motorC) = 0;
  i=0;
  x = 0;
  xneg = 0;
  y = 0;
  yneg = 0;
}

void silverRote(){
	forcarCurva(1);
  eixoX = false;
  direction = (!SensorValue(touchSensor))?false:true;
  while(true){
  	if (SensorValue(lightSensor) >= prata){
      motor[motorB] = speed;
      motor[motorC] = speed;
    }else if (SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata){//branco
      correcao();
      wait1Msec(200);
      //se apos um tempo, continuar no branco
      if(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){//continua no branco
        correcao();
        wait1Msec(500);
        if(SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata){
		      //curva, rotaciona ate achar preto ou prata
		      while(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){
		        //o sentido da rotacao eh dado pelo vetor rote
		        motor[motorB] = speed;//curva
		        motor[motorC] = -speed;
		      }
		      wait1Msec(120);
		      if(SensorValue(lightSensor) < branco){
		        direction = (!SensorValue(touchSensor))?true:false;
		        eixoX = true;
		      	break;
		      }
		      if(SensorValue(touchSensor)){
			      while(SensorValue(touchSensor)){
			      	motor[motorB] = 0;
	      			motor[motorC] = 0;
		        }
		      }else{
		        while(!SensorValue(touchSensor)){
			      	motor[motorB] = 0;
	      			motor[motorC] = 0;
		        }
		      }
		      direction = (!SensorValue(touchSensor))?true:false;
		    }
      }
    }
  }
}
