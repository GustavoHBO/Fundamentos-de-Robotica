#pragma config(Sensor, S3,		 lightSensor,					sensorLightActive)
#pragma config(Sensor, S1,		 touchSensor,		 sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//
#pragma platform(NXT)
#define speed 30
#define prata 65
#define branco 45
/*--------------------------------------------------------------------------------------------------------*\
|*																																																				*|
|*																					 - Line Tracker -																							*|
|*																						ROBOTC on NXT																								*|
|*																																																				*|
|*	This program allows your taskbot to follow a line in reverse.																					*|
|*																																																				*|
|*																				ROBOT CONFIGURATION																							*|
|*		NOTES:																																															*|
|*		1)	The Light Sensor is attached to the front of the robot.																			 		*|
|*		2)	Be sure to take readings of your Light Sensor over the light and dark areas.	Once you have			*|
|*				the values, add them and divide by 2 to find your threshold.	Then, use your threshold as a			*|
|*				comparison in your program.																																			*|
|*																																																				*|
|*		MOTORS & SENSORS:																																										*|
|*		[I/O Port]							[Name]							[Type]							[Description]												*|
|*		Port B									motorB							NXT									Right motor													*|
|*		Port C									motorC							NXT									Left motor													*|
|*		Port 1									touchSensor					Touch Sensor				Front mounted												*|
|*		Port 3									lightSensor					Light Sensor				Front mounted												*|
\*--------------------------------------------------------------------------------------------------------*/

bool activate = false, fromLeft =false, eixoX = true, curve =false, direction=true, rest =false;
bool restoreCurve =false;
int i=0;
int x = 0, y = 0, xneg=0, yneg=0, dist =0;

void forcarCurva(int s);
void correcao(int max);
void resetar();
void silverRote();
//funcao pra conectar com a supervisao, que deve ja estar executando
void checkBTLinkConnected(){
  while(true){
		if (nBTCurrentStreamIndex >= 0)
			break; // An existing Bluetooth connection is present.
  }
	setBluetoothRawDataMode();
	while (!bBTRawMode){
		// Wait for Bluecore to enter raw data mode
		wait1Msec(50);
	}
}

//funcao que envia os dados para a supervisao
task Sender(){
	ubyte msg[5];
	while (true){
	  dist=((nMotorEncoder(motorB)+nMotorEncoder(motorC))/2)/20.8;//20.809248554;

		msg[0] = SensorValue(lightSensor);
		msg[1] = SensorValue(touchSensor);
		if (i==20)
		  nxtDisplayCenteredBigTextLine(3, "Silver\nRote");
		else
      nxtDisplayCenteredBigTextLine(3, "Rote %d",i);
		if(!curve && !restoreCurve){
			if(eixoX && direction){//+x
			  x = dist -xneg -y -yneg;//resultado em cm
		  }else if(eixoX && !direction){//-x
			  xneg = dist -x -y -yneg;//resultado em cm
		  }else if(!eixoX && direction){//+y
		    y = dist -yneg -x -xneg;//resultado em cm
		  }else {//-y
		    yneg = dist -y -x -xneg;//resultado em cm
		  }
			msg[2] = x-xneg;
			msg[3] = y-yneg;
			if (rest)
			  dist=120;
			msg[4] = dist;
			//envia
			nxtWriteRawBluetooth(msg, 5);
	  }else{
	    restoreCurve = true;
	  }
	  if ((restoreCurve && !curve)){
	    nMotorEncoder(motorB) = 0;
	    nMotorEncoder(motorC) = 0;
	    x = 0;
	    xneg = 0;
	    y = 0;
	    yneg = 0;
	    restoreCurve  = false;
	  }
	  //reset
	  if(dist>100){
	    nMotorEncoder(motorB) = 0;
	    nMotorEncoder(motorC) = 0;
	    x = 0;
	    xneg = 0;
	    y = 0;
	    yneg = 0;
	  }
		wait1Msec(80);//delay necessario pra nao embaralhar os pacotes
	}
	return;
}

//funcao que recebe os comandos da supervisao
task Receiver(){
  int nNumbBytesRead;
	ubyte BytesRead[1];
  while (true){
    //faz uma leitura no buffer
	  nNumbBytesRead = nxtReadRawBluetooth(&BytesRead[0],  1);

		if (nNumbBytesRead == 0){//se nao tem nada, da um tempinho
			wait1Msec(10);
		}else if (nNumbBytesRead == 1 && BytesRead[0] == 'i'){//sinal de iniciar
		  nxtDisplayCenteredBigTextLine(3, "Working");
		  rest = false;
		  activate =true;
		}else if (nNumbBytesRead == 1 && BytesRead[0] == 'p'){//sinal de parar
		  nxtDisplayCenteredBigTextLine(3, "Idle");
		  motor[motorB] = 0;
		  motor[motorC] = 0;
		  activate =false;
		}else if (nNumbBytesRead == 1 && BytesRead[0] == 'r'){//sinal de reset
		  resetar();
		}
  }
}

task main(){

  //                      { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10};
  int rote[12]=           { 1,-1,-1, 1,-1,-1,-1,-1, 1, 1, 1, 1};//1 =right, -1 left  /curva (sem o prata)
  //int rotaEixos[11] =     { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};//0 = x, 1 = y       /eixo (sem o prata)
  int rotaDirection[12] = { 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0};//0 = +, 1 = -       /increment (sem o prata)

  checkBTLinkConnected();//inicia a conexao
  wait1Msec(50);// The program waits 50 milliseconds to initialize the light sensor.
  StartTask(Sender);//ativa o envio de dados
  StartTask(Receiver);//ativa a recepcao de dados

  while(true){if(activate){  //so executa se receber o sinal mudando activate pra true
    //sensor lendo preto
    if(SensorValue(lightSensor) < branco){//mantem direcao reta
      motor[motorB] = speed;
      motor[motorC] = speed;
    //sensor lendo prata
    // }else if(SensorValue(lightSensor) >= prata){//mantem direcao reta
      // motor[motorB] = speed;
      // motor[motorC] = speed;
    //sensor lendo branco
    }else if((i==2/*&&dist>44*/ || i==6/*&&dist>90*/) && SensorValue(lightSensor) >= prata){//prata
      silverRote();
    }else if (SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata){//branco
      correcao(15);
      //se apos um tempo, continuar no branco
      if(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){//continua no branco
        correcao(42);
		    //se apos outro intervalo de tempo continuar no branco, chegamos em uma curva
		    if(SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata){
		      curve=true;
		      //curva, rotaciona ate achar preto ou prata
		      while(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){
		        //o sentido da rotacao eh dado pelo vetor rote
		        motor[motorB] = (-1)*rote[i]*speed;//curva
		        motor[motorC] = rote[i]*speed;
		      }
		      i++;
	        //se a proxima curva for a 1, 3.. estamos andando no eixo Y
		      if(eixoX)  //teste
		        eixoX=false;
		      else
		        //se nao estamos andando no eixo X
		        eixoX=true;

		      if(rotaDirection[i])//sabemos o eixo pela proxima curva (definidos com base no mapa)
		        direction=false;
		      else
		        direction=true;
			    curve=false;
			    dist=0;
			    nMotorEncoder(motorB) = 0;
	        nMotorEncoder(motorC) = 0;
	        wait1Msec(2);
		    }
      }
    }
    if (i==9 && dist > 35){//curva pra voltar a base aos 41cm depois da curva 8
    	curve = true;
    	forcarCurva(-1);
    	while(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){
        //o sentido da rotacao eh dado pelo vetor rote
        motor[motorB] = (-1)*rote[i]*speed;//curva
        motor[motorC] = rote[i]*speed;
      }
    	i++;

    	if(eixoX)
        eixoX=false;
      else//se nao estamos andando no eixo X
        eixoX=true;

      curve=false;
      if(rotaDirection[i])//sabemos o eixo pela proxima curva (definidos com base no mapa)
        direction=false;
      else
        direction=true;
		}else if(i==11){
		  resetar();
		  rest=true;
		}
  }}
}
//calculo da odometria
//cm = ciclos
//17.3 = 360  | x = 360/17.3
//1 = x       | x =  20.809248554

//21.3 (compensar a perda com corrcoes de direcao)
void correcao(int max){
  if(fromLeft){//se veio da esquerda tenta a 1 correcao pra direita
    motor[motorB] = 0;//direita
    motor[motorC] = speed;
    fromLeft =false;
  }else{//se veio da direita tenta a 1 correcao pra esquerda
    motor[motorB] = speed;//esquerda
    motor[motorC] = 0;
    fromLeft =true;
  }
  int esp =0;
	while(esp < max && (SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata)){
	  wait1Msec(10);
	  esp++;
  }
}
void correcaoBruta(){
	int w = 1;
	if(fromLeft){
		w = -1;
		fromLeft = false;
	}else{
		fromLeft = true;
	}
	motor[motorB] = w*speed;//direita
	motor[motorC] = (-1)*w*speed;
	int esp =0;
	while(esp < 10 && (SensorValue(lightSensor)< prata)){
	  wait1Msec(25);
	  esp++;
	}
}
void forcarCurva(int s){
  motor[motorB] = speed;
  motor[motorC] = speed;
  wait1Msec(400);
  curve = true;
	motor[motorB] = s*speed;
  motor[motorC] = (-1)*s*speed;
  wait1Msec(510);
  curve = false;
}
void resetar(){
	activate = false;
  nxtDisplayCenteredBigTextLine(3, "Idle");
  motor[motorB] = 0;
  motor[motorC] = 0;
  eixoX = true;
  curve =false;
  direction=true;
  nMotorEncoder(motorB) = 0;
	nMotorEncoder(motorC) = 0;
  i=0;
  x = 0;
  xneg = 0;
  y = 0;
  yneg = 0;
  dist = 0;
}

void silverRote(){
  int iold =i;
  i=20;
	forcarCurva(1);
  eixoX = false;
  direction = (!SensorValue(touchSensor))?false:true;
  while(true){
  	if (SensorValue(lightSensor) >= prata){
      motor[motorB] = speed;
      motor[motorC] = speed;
    }else if (SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata){//branco
      correcao(15);
      //se apos um tempo, continuar no branco
      if(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){//continua no branco
        correcao(43);
        if(SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata){
        correcaoBruta();
        if(SensorValue(lightSensor) >= branco && SensorValue(lightSensor) < prata){//curva
		      //curva, rotaciona ate achar preto ou prata
          curve = true;
		      while(SensorValue(lightSensor) >= branco && SensorValue(lightSensor)< prata){
		        //o sentido da rotacao eh dado pelo vetor rote
		        motor[motorB] = speed;//curva
		        motor[motorC] = -speed;
		      }
		      wait1Msec(120);
		      if(direction)
		        direction = false;
		      else
		        direction = true;
		      curve = false;
		      if(SensorValue(lightSensor) < branco){
		        direction = (!SensorValue(touchSensor))?false:true;
		        eixoX = true;
		        i=iold;
		      	break;
		      }
		      if(SensorValue(touchSensor)){
			      while(SensorValue(touchSensor)){
			      	motor[motorB] = 0;
	      			motor[motorC] = 0;
		        }
		      }else{
		        while(!SensorValue(touchSensor)){
			      	motor[motorB] = 0;
	      			motor[motorC] = 0;
		        }
		      }
		      wait1Msec(500);
		    }
		    }
      }
    }
  }
}
