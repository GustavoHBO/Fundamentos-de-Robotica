#pragma config(Sensor, S3,		 lightSensor,					sensorLightActive)
#pragma config(Sensor, S1,		 touchSensor,		 sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//
#pragma platform(NXT)
#define speed 30
/*--------------------------------------------------------------------------------------------------------*\
|*																																																				*|
|*																					 - Line Tracker -																							*|
|*																						ROBOTC on NXT																								*|
|*																																																				*|
|*	This program allows your taskbot to follow a line in reverse.																					*|
|*																																																				*|
|*																				ROBOT CONFIGURATION																							*|
|*		NOTES:																																															*|
|*		1)	The Light Sensor is attached to the front of the robot.																					 *|
|*		2)	Be sure to take readings of your Light Sensor over the light and dark areas.	Once you have			*|
|*				the values, add them and divide by 2 to find your threshold.	Then, use your threshold as a			*|
|*				comparison in your program.																																			*|
|*																																																				*|
|*		MOTORS & SENSORS:																																										*|
|*		[I/O Port]							[Name]							[Type]							[Description]												*|
|*		Port B									motorB							NXT									Right motor													*|
|*		Port C									motorC							NXT									Left motor													*|
|*		Port 1									touchSensor					Touch Sensor				Front mounted												*|
|*		Port 3									lightSensor					Light Sensor				Front mounted												*|
\*--------------------------------------------------------------------------------------------------------*/

bool activate = false, eixoX = true, curve =false, direction=true;

//funcao pra conectar com a supervisao, que deve ja estar executando
void checkBTLinkConnected(){
  while(true){
		if (nBTCurrentStreamIndex >= 0)
			break; // An existing Bluetooth connection is present.
  }
	setBluetoothRawDataMode();
	while (!bBTRawMode){
		// Wait for Bluecore to enter raw data mode
		wait1Msec(50);
	}
}

//funcao que envia os dados para a supervisao
task Sender(){
	ubyte msg[5];
	bool restoreCurve =false;
	int x = 0, y = 0, xneg=0, yneg=0;
  int dist =0;
	while (true){
	  dist=((nMotorEncoder(motorB)+nMotorEncoder(motorC))/2)/21.3;//20.809248554;

		msg[0] = SensorValue(lightSensor);
		msg[1] = SensorValue(touchSensor);

		if(!curve && !restoreCurve){
			if(eixoX && direction){//+x
			  x = dist -xneg -y -yneg;//resultado em cm
		  }else if(eixoX && !direction){//-x
			  xneg = dist -x -y -yneg;//resultado em cm
		  }else if(!eixoX && direction){//+y
		    y = dist -yneg -x -xneg;//resultado em cm
		  }else {//-y
		    yneg = dist -y -x -xneg;//resultado em cm
		  }
			msg[2] = x-xneg;
			msg[3] = y-yneg;
			msg[4] = dist;
			//envia
			nxtWriteRawBluetooth(msg, 5);
	  }else{
	    restoreCurve = true;
	  }
	  if (restoreCurve && !curve){
	    nMotorEncoder(motorB) = 0;
	    nMotorEncoder(motorC) = 0;
	    x = 0;
	    xneg = 0;
	    y = 0;
	    yneg = 0;
	    restoreCurve  = false;
	  }
	  //reset
	  if(dist>100){
	    nMotorEncoder(motorB) = 0;
	    nMotorEncoder(motorC) = 0;
	    x = 0;
	    xneg = 0;
	    y = 0;
	    yneg = 0;
	  }
		wait1Msec(80);//delay necessario pra nao embaralhar os pacotes
	}
	return;
}

//funcao que recebe os comandos da supervisao
task Receiver(){
  int nNumbBytesRead;
	ubyte BytesRead[1];
  while (true){
    //faz uma leitura no buffer
	  nNumbBytesRead = nxtReadRawBluetooth(&BytesRead[0],  1);

		if (nNumbBytesRead == 0){//se nao tem nada, da um tempinho
			wait1Msec(10);
		}else if (nNumbBytesRead == 1 && BytesRead[0] == 'i'){//sinal de iniciar
		  nxtDisplayCenteredBigTextLine(3, "Working");
		  activate =true;
		}else if (nNumbBytesRead == 1 && BytesRead[0] == 'p'){//sinal de parar
		  nxtDisplayCenteredBigTextLine(3, "Idle");
		  motor[motorB] = 0;
		  motor[motorC] = 0;
		  activate =false;
		}
  }
}

task main(){
  int i=0;
  //int rote[17]= {1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,1};
  int rote[11]= {1,-1,-1,1,-1,-1,-1,-1,1,1,1};
  bool fromLeft =false;

  checkBTLinkConnected();//inicia a conexao
  wait1Msec(50);// The program waits 50 milliseconds to initialize the light sensor.
  StartTask(Sender);//ativa o envio de dados
  StartTask(Receiver);//ativa a recepcao de dados

  while(true){if(activate){  //so executa se receber o sinal mudando activate pra true
    //sensor lendo preto
    if(SensorValue(lightSensor) < 45){//mantem direcao reta
      motor[motorB] = speed;
      motor[motorC] = speed;
    //sensor lendo prata
    // }else if(SensorValue(lightSensor) >= 64){//mantem direcao reta
      // motor[motorB] = speed;
      // motor[motorC] = speed;
    //sensor lendo branco
    }else if(SensorValue(lightSensor) >= 64){//prata
      motor[motorB] = speed;
	    motor[motorC] = speed;
	    wait1Msec(300);
  		motor[motorB] = speed;
	    motor[motorC] = -speed;
	    wait1Msec(550);

      while(true){
      	if (SensorValue(lightSensor) >= 64){
		      motor[motorB] = speed;
		      motor[motorC] = speed;
	      }else if (SensorValue(lightSensor) >= 45 && SensorValue(lightSensor) < 64){//branco
		      if(fromLeft){//se veio da esquerda tenta a 1 correcao pra direita
		        motor[motorB] = speed-20;//direita
		        motor[motorC] = speed;
		        fromLeft =false;
		      }else{//se veio da direita tenta a 1 correcao pra esquerda
		        motor[motorB] = speed;//esquerda
		        motor[motorC] = speed-20;
		        fromLeft =true;
		      }
		      wait1Msec(200);
		      //se apos um tempo, continuar no branco
		      if(SensorValue(lightSensor) >= 45 && SensorValue(lightSensor)< 64){//continua no branco
		        if(fromLeft){//tenta pro lado oposto ao da 1 tentativa
		          motor[motorB] = speed-20;//vira para a direita
		          motor[motorC] = speed;
		          fromLeft =true;
		        }else{
		          motor[motorB] = speed;//vira para a esquerda
		          motor[motorC] = speed-20;
		          fromLeft =false;
		        }
		        wait1Msec(500);
		        if(SensorValue(lightSensor) >= 45 && SensorValue(lightSensor) < 64){
				      //curva, rotaciona ate achar preto ou prata
				      while(SensorValue(lightSensor) >= 45 && SensorValue(lightSensor)< 64){
				        //o sentido da rotacao eh dado pelo vetor rote
				        motor[motorB] = speed;//curva
				        motor[motorC] = -speed;
				      }
				      if(SensorValue(lightSensor) < 45){
				      	break;
				      }
				      if(SensorValue(touchSensor)){
					      while(SensorValue(touchSensor)){
					      	motor[motorB] = 0;
			      			motor[motorC] = 0;
				        }
				      }else{
				        while(!SensorValue(touchSensor)){
					      	motor[motorB] = 0;
			      			motor[motorC] = 0;
				        }
				      }

				    }
		      }
		    }
	    }
    }else if (SensorValue(lightSensor) >= 45 && SensorValue(lightSensor) < 64){//branco
      if(fromLeft){//se veio da esquerda tenta a 1 correcao pra direita
	      motor[motorB] = speed-20;//direita
	      motor[motorC] = speed;
	      fromLeft =false;
	    }else{//se veio da direita tenta a 1 correcao pra esquerda
	      motor[motorB] = speed;//esquerda
	      motor[motorC] = speed-20;
	      fromLeft =true;
	    }
      wait1Msec(200);
      //se apos um tempo, continuar no branco
      if(SensorValue(lightSensor) >= 45 && SensorValue(lightSensor)< 64){//continua no branco
        if(fromLeft){//tenta pro lado oposto ao da 1 tentativa
		      motor[motorB] = speed-20;//vira para a direita
		      motor[motorC] = speed;
		      fromLeft =true;
		    }else{
		      motor[motorB] = speed;//vira para a esquerda
		      motor[motorC] = speed-20;
		      fromLeft =false;
		    }
		    wait1Msec(500);
		    //se apos outro intervalo de tempo continuar no branco, chegamos em uma curva
		    if(SensorValue(lightSensor) >= 45 && SensorValue(lightSensor) < 64){
		      curve=true;
		      //curva, rotaciona ate achar preto ou prata
		      while(SensorValue(lightSensor) >= 45 && SensorValue(lightSensor)< 64){
		        //o sentido da rotacao eh dado pelo vetor rote
		        motor[motorB] = (-1)*rote[i]*speed;//curva
		        motor[motorC] = rote[i]*speed;
		      }
		      i++;
		      //if(i==1||i==3||i==4||i==6||i==8||i==10||i==11||i==13||i==15)//sabemos o eixo pela proxima curva (definidos com base no mapa)
		        //se a proxima curva for a 1, 3.. estamos andando no eixo Y
		      if(i==1||i==3||i==5||i==7||i==9)  //teste
		        eixoX=false;
		      else
		        //se nao estamos andando no eixo X
		        eixoX=true;

		      if(i==2||i==5||i==6||i==8)//sabemos o eixo pela proxima curva (definidos com base no mapa)
		        //se a proxima curva for a 1, 4, 9.. estamos andando no sentido negativo
		        direction=false;
		      else
		        //se nao estamos andando no eixo X
		        direction=true;
		      curve=false;
		      if(i==17){//ultima curva
		        //zerar variaveis
		        i=0;
		        nMotorEncoder(motorB) = 0;
	          nMotorEncoder(motorC) = 0;
	          activate = false;
		      }
		    }
      }
    }
  }}
}
//calculo da odometria
//cm = ciclos
//17.3 = 360  | x = 360/17.3
//1 = x       | x =  20.809248554

//21.3 (compensar a perda com corrcoes de direcao)
